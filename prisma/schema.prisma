generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Account {
  id                 String  @id @default(cuid())
  userId             String  @map("user_id")
  type               String
  provider           String
  providerAccountId  String  @map("provider_account_id")
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?

  user               User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  avatar        String?
  password      String
  salt          String

  score         Int       @default(0)

  accounts      Account[]
  sessions      Session[]
  captions      Caption[]
  exams         Exam[]
  notebooks     Notebook[]
  spellingResults SpellingResult[]
  scoreRecords    ScoreRecord[]
  packages         Package[]
  sign         SignRecord[]

  created_at    Int
  last_updated  Int?

  @@map("users")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

// model Email {
//   id            Int     @id @default(autoincrement())
//   userUid       String
//   email         String  @unique
// }

model Caption {
  id           String        @id @default(cuid())
  title        String
  content      String?       @db.LongText
  published    Boolean       @default(false)
  publisher    User?         @relation(fields: [publisherId], references: [id])
  publisherId  String?       @map("publisher_id")

  movieId      String?       @map("movie_id")

  paragraphs   Paragraph[]
  exams        Exam[]

  created_at    Int
  last_updated  Int?
}

model Paragraph {
  id           String   @id @default(cuid())
  line         String
  text1        String   @db.LongText
  text2        String   @db.LongText
  start        String
  end          String
  language     String?

  captionId    String   @map("caption_id")
  caption      Caption  @relation(fields: [captionId], references: [id], onDelete: Cascade)

  // 该段落被拼写（正确、错误、跳过）的记录
  spellings       SpellingResult[]
  // 该段落有哪些单词被记录进单词本
  words        Word[]

  @@map("paragraphs")
}

model Scene {
  id           String   @id @default(cuid())

  // 场景开始段落
  start        String
  // 场景结束段落
  end          String

  @@map("scenes")
}

// 阅读记录
model Reading {
  id           String    @id @default(cuid())

  @@map("readings")
}

model Exam {
  id           String    @id @default(cuid())

  status       Int       @default(1)

  captionId    String    
  caption      Caption   @relation(fields: [captionId], references: [id], onDelete: Cascade)

  user         User?     @relation(fields: [userId], references: [id])
  userId       String?   @map("publisher_id")

  curParagraphId String? @map("cur_paragraph_id")
  combo          Int     @default(0)
  maxCombo       Int     @default(0) @map("max_combo")

  spellings       SpellingResult[]

  created_at    Int
  last_updated  Int?

  @@map("exams")
}

model SpellingResult {
  id           String     @id @default(cuid())
  type         Int

  userId       String?   @map("user_id")
  user         User?     @relation(fields: [userId], references: [id])

  paragraphId  String     @map("paragraph_id")
  paragraph    Paragraph  @relation(fields: [paragraphId], references: [id], onDelete: Cascade)

  examId  String?     @map("exam_id")
  exam    Exam?       @relation(fields: [examId], references: [id], onDelete: Cascade)

  input   String?

  created_at    Int

  @@map("spelling_results")
}

model Notebook {
  id                String     @id @default(cuid())

  title             String?

  user              User?     @relation(fields: [userId], references: [id])
  userId            String?   @map("publisher_id")

  words             Word[]

  created_at    Int
  last_updated  Int?

  @@map("notebooks")
}

model Word {
  id                    String     @id @default(cuid())

  text                  String

  notebookId            String        @map("notebook_id")
  notebook              Notebook?     @relation(fields: [notebookId], references: [id])

  paragraphId           String        @map("paragraph_id")
  paragraph             Paragraph     @relation(fields: [paragraphId], references: [id])

  created_at            Int

  @@map("words")
}

// 积分记录
model ScoreRecord {
  id                    String     @id @default(cuid())

  user              User?     @relation(fields: [userId], references: [id])
  userId            String?   @map("user_id")

  type              Int
  number            Int
  desc              String?

  created_at            Int

  @@map("score_records")
}

// 签到记录
model SignRecord {
  id                    String     @id @default(cuid())

  user                  User?     @relation(fields: [userId], references: [id])
  userId                String?   @map("user_id")
  // 星期几
  day                  Int
  created_at            Int

  @@map("sign_records")
}


// 游戏道具
model Item {
  id                    String     @id @default(cuid())

  type                  Int

  name                  String
  price                 Int

  packages              Package[]

  created_at            Int

  @@map("items")
}

// user package
model Package {
  id                    String     @id @default(cuid())

  item                  Item      @relation(fields: [itemId], references: [id])
  itemId                String       @map("item_id")
  num                   Int

  user                  User     @relation(fields: [userId], references: [id])
  userId                String   @map("user_id")

  created_at            Int

  @@map("packages")
}
